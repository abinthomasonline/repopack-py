import os
from datetime import datetime
from typing import Dict, Any, List
import xml.dom.minidom as minidom
import xml.etree.ElementTree as ET
from .exceptions import OutputGenerationError
from .utils.tree_generator import generate_tree_string


def generate_output(
    root_dir: str,
    config: Dict[str, Any],
    sanitized_files: List[Dict[str, str]],
    all_file_paths: List[str],
    file_char_counts: Dict[str, int],
) -> None:
    """
    Generate the output file based on the specified configuration.

    Args:
        root_dir (str): The root directory of the repository.
        config (Dict[str, Any]): The configuration dictionary.
        sanitized_files (List[Dict[str, str]]): List of sanitized file contents.
        all_file_paths (List[str]): List of all file paths in the repository.
        file_char_counts (Dict[str, int]): Dictionary of file paths and their character counts.

    Raises:
        OutputGenerationError: If there's an error during output generation.
    """
    output_path: str = os.path.join(root_dir, config["output"]["file_path"])
    tree_string: str = generate_tree_string(all_file_paths)

    try:
        if config["output"]["style"] == "xml":
            generate_xml_output(
                output_path, config, sanitized_files, all_file_paths, file_char_counts, tree_string
            )
        else:
            generate_plain_output(
                output_path, config, sanitized_files, all_file_paths, file_char_counts, tree_string
            )
    except Exception as e:
        raise OutputGenerationError(f"Error generating output: {str(e)}")


def generate_plain_output(
    output_path: str,
    config: Dict[str, Any],
    sanitized_files: List[Dict[str, str]],
    all_file_paths: List[str],
    file_char_counts: Dict[str, int],
    tree_string: str,
) -> None:
    """
    Generate plain text output file.

    Args:
        output_path (str): Path to the output file.
        config (Dict[str, Any]): The configuration dictionary.
        sanitized_files (List[Dict[str, str]]): List of sanitized file contents.
        all_file_paths (List[str]): List of all file paths in the repository.
        file_char_counts (Dict[str, int]): Dictionary of file paths and their character counts.
        tree_string (str): String representation of the repository structure.
    """
    with open(output_path, "w", encoding="utf-8") as f:
        # Write header
        f.write("=" * 64 + "\n")
        f.write("Repopack Output File\n")
        f.write("=" * 64 + "\n\n")
        f.write(f"This file was generated by Repopack on: {datetime.now().isoformat()}\n\n")

        # Write purpose
        f.write("Purpose:\n--------\n")
        f.write("This file contains a packed representation of the entire repository's contents.\n")
        f.write("It is designed to be easily consumable by AI systems for analysis, code review,\n")
        f.write("or other automated processes.\n\n")

        # Write notes
        if config["output"]["show_line_numbers"]:
            f.write("- Line numbers have been added to the beginning of each line.\n")

        # Write repository structure
        f.write("Repository Structure:\n---------------------\n")
        f.write(tree_string + "\n\n")

        # Write repository files
        f.write("=" * 64 + "\n")
        f.write("Repository Files\n")
        f.write("=" * 64 + "\n\n")

        for file in sanitized_files:
            f.write("=" * 16 + "\n")
            f.write(f"File: {file['path']}\n")
            f.write("=" * 16 + "\n")
            f.write(file["content"] + "\n\n")

        # Write top files by character count
        top_files_length: int = config["output"]["top_files_length"]
        if top_files_length > 0:
            f.write("\n" + "=" * 64 + "\n")
            f.write(f"Top {top_files_length} Files by Character Count\n")
            f.write("=" * 64 + "\n")

            sorted_files: List[tuple[str, int]] = sorted(
                file_char_counts.items(), key=lambda x: x[1], reverse=True
            )
            for i, (file_path, char_count) in enumerate(sorted_files[:top_files_length], 1):
                f.write(f"{i}. {file_path} ({char_count} chars)\n")

            f.write("\n")


def generate_xml_output(
    output_path: str,
    config: Dict[str, Any],
    sanitized_files: List[Dict[str, str]],
    all_file_paths: List[str],
    file_char_counts: Dict[str, int],
    tree_string: str,
) -> None:
    """
    Generate XML output file.

    Args:
        output_path (str): Path to the output file.
        config (Dict[str, Any]): The configuration dictionary.
        sanitized_files (List[Dict[str, str]]): List of sanitized file contents.
        all_file_paths (List[str]): List of all file paths in the repository.
        file_char_counts (Dict[str, int]): Dictionary of file paths and their character counts.
        tree_string (str): String representation of the repository structure.
    """
    root: ET.Element = ET.Element("repopack_output")

    # Add summary section
    summary: ET.Element = ET.SubElement(root, "summary")
    ET.SubElement(summary, "header").text = (
        f"Repopack Output File"
        "\nThis file was generated by Repopack on: {datetime.now().isoformat()}"
    )
    ET.SubElement(summary, "purpose").text = (
        "This file contains a packed representation of the entire repository's contents. "
        "It is designed to be easily consumable by AI systems for analysis, code review, "
        "or other automated processes."
    )

    # Add notes
    notes: ET.Element = ET.SubElement(summary, "notes")
    if config["output"]["remove_comments"]:
        ET.SubElement(notes, "note").text = "Code comments have been removed."
    if config["output"]["show_line_numbers"]:
        ET.SubElement(
            notes, "note"
        ).text = "Line numbers have been added to the beginning of each line."

    # Add repository structure
    ET.SubElement(root, "repository_structure").text = tree_string

    # Add repository files
    files: ET.Element = ET.SubElement(root, "repository_files")
    for file in sanitized_files:
        file_elem: ET.Element = ET.SubElement(files, "file")
        file_elem.set("path", file["path"])
        file_elem.text = file["content"]

    # Add top files by character count
    top_files_length: int = config["output"]["top_files_length"]
    if top_files_length > 0:
        top_files: ET.Element = ET.SubElement(root, "top_files")
        top_files.set("count", str(top_files_length))
        sorted_files: List[tuple[str, int]] = sorted(
            file_char_counts.items(), key=lambda x: x[1], reverse=True
        )
        for i, (file_path, char_count) in enumerate(sorted_files[:top_files_length], 1):
            file_elem: ET.Element = ET.SubElement(top_files, "file")
            file_elem.set("rank", str(i))
            file_elem.set("path", file_path)
            file_elem.set("char_count", str(char_count))

    # Pretty print the XML
    xml_string: str = ET.tostring(root, encoding="unicode")
    pretty_xml: str = minidom.parseString(xml_string).toprettyxml(indent="  ")

    # Write to file
    with open(output_path, "w", encoding="utf-8") as f:
        f.write(pretty_xml)
