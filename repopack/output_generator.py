import os
from datetime import datetime
from typing import Dict, Any, List
import xml.dom.minidom as minidom
import xml.etree.ElementTree as ET
from .exceptions import OutputGenerationError
from .utils.tree_generator import generate_tree_string


def generate_output(
    root_dir: str,
    config: Dict[str, Any],
    sanitized_files: List[Dict[str, str]],
    all_file_paths: List[str],
    file_char_counts: Dict[str, int],
):
    output_path = os.path.join(root_dir, config["output"]["file_path"])
    tree_string = generate_tree_string(all_file_paths)

    try:
        if config["output"]["style"] == "xml":
            generate_xml_output(
                output_path, config, sanitized_files, all_file_paths, file_char_counts, tree_string
            )
        else:
            generate_plain_output(
                output_path, config, sanitized_files, all_file_paths, file_char_counts, tree_string
            )
    except Exception as e:
        raise OutputGenerationError(f"Error generating output: {str(e)}")


def generate_plain_output(
    output_path: str,
    config: Dict[str, Any],
    sanitized_files: List[Dict[str, str]],
    all_file_paths: List[str],
    file_char_counts: Dict[str, int],
    tree_string: str,
):
    with open(output_path, "w", encoding="utf-8") as f:
        f.write("=" * 64 + "\n")
        f.write("Repopack Output File\n")
        f.write("=" * 64 + "\n\n")
        f.write(f"This file was generated by Repopack on: {datetime.now().isoformat()}\n\n")
        f.write("Purpose:\n--------\n")
        f.write("This file contains a packed representation of the entire repository's contents.\n")
        f.write("It is designed to be easily consumable by AI systems for analysis, code review,\n")
        f.write("or other automated processes.\n\n")
        if config["output"]["show_line_numbers"]:
            f.write("- Line numbers have been added to the beginning of each line.\n")
        f.write("Repository Structure:\n---------------------\n")
        f.write(tree_string + "\n\n")
        f.write("=" * 64 + "\n")
        f.write("Repository Files\n")
        f.write("=" * 64 + "\n\n")

        for file in sanitized_files:
            f.write("=" * 16 + "\n")
            f.write(f"File: {file['path']}\n")
            f.write("=" * 16 + "\n")
            f.write(file["content"] + "\n\n")

        top_files_length = config["output"]["top_files_length"]
        if top_files_length > 0:
            f.write("\n" + "=" * 64 + "\n")
            f.write(f"Top {top_files_length} Files by Character Count\n")
            f.write("=" * 64 + "\n")

            sorted_files = sorted(file_char_counts.items(), key=lambda x: x[1], reverse=True)
            for i, (file_path, char_count) in enumerate(sorted_files[:top_files_length], 1):
                f.write(f"{i}. {file_path} ({char_count} chars)\n")

            f.write("\n")


def generate_xml_output(
    output_path: str,
    config: Dict[str, Any],
    sanitized_files: List[Dict[str, str]],
    all_file_paths: List[str],
    file_char_counts: Dict[str, int],
    tree_string: str,
):
    root = ET.Element("repopack_output")

    summary = ET.SubElement(root, "summary")
    ET.SubElement(
        summary, "header"
    ).text = f"Repopack Output File\nThis file was generated by Repopack on: {datetime.now().isoformat()}"
    ET.SubElement(summary, "purpose").text = (
        "This file contains a packed representation of the entire repository's contents. "
        "It is designed to be easily consumable by AI systems for analysis, code review, "
        "or other automated processes."
    )

    notes = ET.SubElement(summary, "notes")
    if config["output"]["remove_comments"]:
        ET.SubElement(notes, "note").text = "Code comments have been removed."
    if config["output"]["show_line_numbers"]:
        ET.SubElement(
            notes, "note"
        ).text = "Line numbers have been added to the beginning of each line."

    ET.SubElement(root, "repository_structure").text = tree_string

    files = ET.SubElement(root, "repository_files")
    for file in sanitized_files:
        file_elem = ET.SubElement(files, "file")
        file_elem.set("path", file["path"])
        file_elem.text = file["content"]

    top_files_length = config["output"]["top_files_length"]
    if top_files_length > 0:
        top_files = ET.SubElement(root, "top_files")
        top_files.set("count", str(top_files_length))
        sorted_files = sorted(file_char_counts.items(), key=lambda x: x[1], reverse=True)
        for i, (file_path, char_count) in enumerate(sorted_files[:top_files_length], 1):
            file_elem = ET.SubElement(top_files, "file")
            file_elem.set("rank", str(i))
            file_elem.set("path", file_path)
            file_elem.set("char_count", str(char_count))

    # Pretty print the XML
    xml_string = ET.tostring(root, encoding="unicode")
    pretty_xml = minidom.parseString(xml_string).toprettyxml(indent="  ")

    with open(output_path, "w", encoding="utf-8") as f:
        f.write(pretty_xml)
